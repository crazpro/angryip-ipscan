/*********************************************************************
 * This is a part of Angry IP Scanner source code                    *
 * http://www.angryziber.com/ipscan/                                 *
 *                                                                   *
 * Written by Angryziber                                             *
 *                                                                   *
 * You may distribute this code as long as this message is not       *
 * removed and it is clear who has written it.                       *
 * You may not rename the program and distribute it.                 *
 *********************************************************************/

// SaveToFile.cpp: implementation of the CSaveToFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ipscan.h"
#include "IpscanDlg.h"
#include "SaveToFile.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaveToFile::CSaveToFile(CIpscanDlg *dlg, BOOL bSaveSelection, LPSTR szFileName, int nFileFormat, BOOL bAppend)
{
	m_dlg = dlg;

	m_bAppend = bAppend;
	
	// Display this error message only if wasn't invoked via command-line
	if (!dlg->m_szDefaultFileName && dlg->m_list.GetItemCount() == 0) 
	{
		dlg->MessageBox("The list is empty!", NULL, MB_OK | MB_ICONHAND);
		return;
	}

	m_saveselection = bSaveSelection;
	if (bSaveSelection && dlg->m_list.GetSelectedCount()==0)
	{		
		dlg->MessageBox("You must select some items first!", NULL, MB_OK | MB_ICONHAND);
		return;
	}
	
	BOOL bResult;
	
	if (szFileName == NULL) 
	{
		bResult = queryFilename();
	}
	else
	{
		bResult = TRUE;
		m_filename = szFileName;
	}

	if (nFileFormat >= 0) 
		m_filetype = nFileFormat;
	
	if (bResult)
	{
		// Start saving!
		m_dlg->status("Exporting...");

		FILE *fileHandle;
		if (m_bAppend)
			fileHandle = fopen(m_filename,"at");
		else
			fileHandle = fopen(m_filename,"wt");
	
		if (!fileHandle) 
		{
			m_dlg->MessageBox("Cannot open file for writing", NULL, MB_OK | MB_ICONHAND);
			return;
		}	

		switch (m_filetype)
		{	
			case FILE_TYPE_CSV:
				saveToCSV(fileHandle);
				break;
			case FILE_TYPE_HTML:
				saveToHTML(fileHandle);
				break;
			case FILE_TYPE_XML:
				saveToXML(fileHandle);
				break;
			case FILE_TYPE_IPPORT_LIST:
				saveToIPPortList(fileHandle);
				break;
			default:
				saveToTXT(fileHandle);
		}		

		// At this point the file has been processed
		fclose(fileHandle);

		// Open the newly saved file only if run by user (not command-line)
		if (szFileName == NULL)
		{
			ShellExecute(0, "open", m_filename, NULL, NULL, SW_SHOWNORMAL);
		}

		m_dlg->status(NULL);
	}
		
}

CSaveToFile::~CSaveToFile()
{
	
}

void CSaveToFile::saveToTXT(FILE *fileHandle)
{	
	CString szHomepage;
	szHomepage.LoadString(IDS_HOMEPAGE);

	if (!m_bAppend)
	{
		fputs("This file was generated by Angry IP Scanner\n"
			  "Visit " + szHomepage + " for the latest version\n\n", fileHandle);
	}

	fputs("\nScanned ", fileHandle);
	in_addr inAddr;	
	inAddr.S_un.S_addr = htonl(0/* TODO: fix g_nStartIP*/); fputs(inet_ntoa(inAddr), fileHandle);
	fputs(" - ", fileHandle);
	inAddr.S_un.S_addr = htonl(0/* TODO: fix g_nEndIP*/); fputs(inet_ntoa(inAddr), fileHandle);
	if (g_options->m_bScanPorts)
	{
		fputs(" (Ports: " + g_options->m_szPorts + ")", fileHandle);
	}
	fputs("\n" + g_options->getCurrentDate() + "\n\n", fileHandle);
	
	int i,j;
	int ws[100];

	CString tmp;
	LV_ITEM it;

	// Output column names
	
	for (i=0; i < g_scanner->getColumnCount(); i++) 
	{
		ws[i] = m_dlg->m_list.GetColumnWidth(i) / 8 + 10;
		
		if (!m_bAppend)
		{			
			g_scanner->getColumnName(i, tmp);
			fprintf(fileHandle,"%-*s",ws[i],tmp);
		}
	}

	if (g_options->m_bScanPorts)
	{
		fprintf(fileHandle,"%s","Open Ports");
	}

	if (!m_bAppend)
		fputs("\n\n", fileHandle);
	

	// Output data
	for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
	{
		it.mask = LVIF_STATE; 
		it.stateMask = LVIS_SELECTED;
		it.iItem = i; 
		it.iSubItem = CL_IP; 

		m_dlg->m_list.GetItem(&it); 
		if (m_saveselection && it.state != LVIS_SELECTED) 
			continue;	// Skip not selected items

		for (j=0; j < g_scanner->getColumnCount(); j++) 
		{
			fprintf(fileHandle, "%-*s",ws[j], m_dlg->m_list.GetItemText(i,j));
		}
		
		if (g_options->m_bScanPorts)
		{
			CString szPorts;
			m_dlg->m_list.GetOpenPorts(i, szPorts);
			fprintf(fileHandle, "%s", szPorts);
		}

		fputs("\n", fileHandle);
	}
}

void CSaveToFile::saveToHTML(FILE *fileHandle)
{
	CString szHomepage;
	szHomepage.LoadString(IDS_SCAN_HOMEPAGE);

	if (m_bAppend)
	{
		m_dlg->MessageBox("Appending to HTML files is not supported!", NULL, MB_OK | MB_ICONHAND);
		return;
	}
	
	// Output HTML head
	fputs("<html>\n<head>\n", fileHandle);
	fputs("<title>Angry IP Scanner: scanning results</title>\n", fileHandle);

	// some CSS magic ;-)
	fputs("<style>body, td { font-family: arial; font-size: 12px; }  </style>\n", fileHandle);

	fputs("<meta name=\"Generator\" content=\"Angry IP Scanner, " + szHomepage + "\">", fileHandle);
	fputs("</head>\n", fileHandle);
	
	// The BODY!
	fputs("<body>\n", fileHandle);
	
	// beginning	
	fputs("<h4>Scanned ", fileHandle);	
	in_addr inAddr;	
	inAddr.S_un.S_addr = htonl(0/* TODO: fix g_nStartIP*/); fputs(inet_ntoa(inAddr), fileHandle);
	fputs(" - ", fileHandle);
	inAddr.S_un.S_addr = htonl(0/* TODO: fix g_nEndIP*/); fputs(inet_ntoa(inAddr), fileHandle);
	if (g_options->m_bScanPorts)
	{
		fputs(" (Ports: " + g_options->m_szPorts + ")", fileHandle);
	}
	fputs("</h4>\n", fileHandle);
	fputs(g_options->getCurrentDate() + "<br><br>\n", fileHandle);

	// the table
	fputs("<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">\n<tr>\n", fileHandle);
	
	int i,j;	

	CString tmp;
	CString szValue;
	LV_ITEM it;

	// Output column names
	for (i=0; i < g_scanner->getColumnCount(); i++) 
	{			
		g_scanner->getColumnName(i, tmp);			
		fprintf(fileHandle, "<td><b>%s</b></td>\n", tmp);
	}	

	if (g_options->m_bScanPorts)
	{
		fputs("<td><b>Open Ports</b></td>\n", fileHandle);
	}	
	
	// Output data
	for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
	{
		fputs("</tr>\n<tr>\n", fileHandle);

		it.mask = LVIF_STATE; 
		it.stateMask = LVIS_SELECTED;
		it.iItem = i; 
		it.iSubItem = CL_IP; 

		m_dlg->m_list.GetItem(&it); 
		if (m_saveselection && it.state != LVIS_SELECTED) 
			continue;	// Skip not selected items

		for (j=0; j < g_scanner->getColumnCount(); j++) 
		{
			szValue = m_dlg->m_list.GetItemText(i,j);
			szValue.Replace("&", "&amp;");
			szValue.Replace("<", "&lt;");
			szValue.Replace(">", "&gt;");
			fprintf(fileHandle, "<td>%s</td>\n", szValue);
		}
		
		if (g_options->m_bScanPorts)
		{
			m_dlg->m_list.GetOpenPorts(i, szValue);
			fprintf(fileHandle, "<td>%s</td>", szValue);
		}			
	}

	// Finish the html
	fputs("</tr>\n", fileHandle);
	fputs("</table>\n", fileHandle);
	fputs("<br><br>Generated by <a href=\"" + szHomepage+ "\">Angry IP Scanner</a>\n", fileHandle);
	fputs("</body>\n</html>\n", fileHandle);
}

void CSaveToFile::saveToXML(FILE *fileHandle)
{
	CString szHomepage;
	szHomepage.LoadString(IDS_SCAN_HOMEPAGE);

	if (m_bAppend)
	{
		m_dlg->MessageBox("Appending to XML files is not supported!", NULL, MB_OK | MB_ICONHAND);
		return;
	}
	
	// Output XML header
	fputs("<?xml version=\"1.0\"?>\n", fileHandle);
	fputs("<scanning_report>\n", fileHandle);
	
	// beginning	
	fputs("\t<options>\n", fileHandle);	
	in_addr inAddr;	
	inAddr.S_un.S_addr = htonl(0/* TODO: fix g_nStartIP*/); 
	fprintf(fileHandle, "\t\t<start_ip>%s</start_ip>\n", inet_ntoa(inAddr));	
	inAddr.S_un.S_addr = htonl(0/* TODO: fix g_nEndIP*/); 
	fprintf(fileHandle, "\t\t<end_ip>%s</end_ip>\n", inet_ntoa(inAddr));
	if (g_options->m_bScanPorts)
	{
		fprintf(fileHandle, "\t\t<ports>%s</ports>\n", g_options->m_szPorts);		
	}
	
	// Print time
	fprintf(fileHandle, "\t\t<time>%s</time>\n", g_options->getCurrentDate());
	
	fputs(
		"\t\t<generator>\n"
			"\t\t\t<name>Angry IP Scanner</name>\n"
			"\t\t\t<url>" + szHomepage + "</url>\n"
		"\t\t</generator>\n", fileHandle);	

	fputs("\t</options>\n", fileHandle);
	
	int i,j;	

	CString szTmp;
	CString szValue;
	LV_ITEM it;

	fputs("\t<ip_list>\n", fileHandle);	
	
	// Output data
	
	for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
	{			
		it.mask = LVIF_STATE; 
		it.stateMask = LVIS_SELECTED;
		it.iItem = i; 
		it.iSubItem = CL_IP; 

		m_dlg->m_list.GetItem(&it); 
		if (m_saveselection && it.state != LVIS_SELECTED) 
			continue;	// Skip not selected items

		fputs("\t\t<ip>\n", fileHandle);

		for (j=0; j < g_scanner->getColumnCount(); j++) 
		{
			// Prepare column name
			g_scanner->getColumnName(j, szTmp);
			szTmp.MakeLower(); 
			szTmp.Replace(".", "");
			for (int nChar = 0; nChar < szTmp.GetLength(); nChar++)
				if (szTmp[nChar] < 'a' || szTmp[nChar] > 'z')
					szTmp.SetAt(nChar, '_');
			// Prepare column value
			szValue = m_dlg->m_list.GetItemText(i,j);
			szValue.Replace("&", "&amp;");
			szValue.Replace("<", "&lt;");
			szValue.Replace(">", "&gt;");
			// Output both
			fprintf(fileHandle, "\t\t\t<%s>%s</%s>\n", szTmp, szValue, szTmp); 				
		}
		
		if (g_options->m_bScanPorts)
		{
			m_dlg->m_list.GetOpenPorts(i, szValue);
			fprintf(fileHandle, "\t\t\t<open_ports>%s</open_ports>\n", szValue);
		}			

		fputs("\t\t</ip>\n", fileHandle);
	}

	

	// Finish the html
	fputs("\t</ip_list>\n", fileHandle);
	fputs("</scanning_report>\n", fileHandle);	
}

void CSaveToFile::saveToCSV(FILE *fileHandle)
{
	int i,j;	

	CString tmp;	
	CString szValue;
	LV_ITEM it;

	// Output data
	for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
	{
		it.mask = LVIF_STATE; 
		it.stateMask = LVIS_SELECTED;
		it.iItem = i; 
		it.iSubItem = CL_IP; 

		m_dlg->m_list.GetItem(&it); 
		if (m_saveselection && it.state != LVIS_SELECTED) 
			continue;	// Skip not selected items

		for (j=0; j < g_scanner->getColumnCount(); j++) 
		{
			szValue = m_dlg->m_list.GetItemText(i,j);
			szValue.Replace(',', ';');		// No extra commas for CSV format :-)
			fprintf(fileHandle, "%s", szValue);
			if (j < g_scanner->getColumnCount() -1) fputs(",", fileHandle);
		}

		if (g_options->m_bScanPorts)
		{
			m_dlg->m_list.GetOpenPorts(i, szValue);
			szValue.Replace(",", "; ");	// No commas!!!
			fprintf(fileHandle, ",%s", szValue);
		}

		fputs("\n", fileHandle);
	}	
}

void CSaveToFile::saveToIPPortList(FILE *fileHandle)
{
	// Exports each IP-Port combination as XXX.XXX.XXX.XXX:XXX

	if (!g_options->m_bScanPorts)
	{
		AfxMessageBox("Sorry, this option can only be used if port scanning is enabled", MB_OK | MB_ICONHAND, 0);
		return;
	}

	int i;	
	CString szIP;	
	CString szPorts;
	LV_ITEM it;

	// Output data
	for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
	{
		it.mask = LVIF_STATE; 
		it.stateMask = LVIS_SELECTED;
		it.iItem = i; 
		it.iSubItem = CL_IP; 

		m_dlg->m_list.GetItem(&it); 
		if (m_saveselection && it.state != LVIS_SELECTED) 
			continue;	// Skip not selected items

		// Get the IP
		szIP = m_dlg->m_list.GetItemText(i, 0);				
		
		// Get the port list
		m_dlg->m_list.GetOpenPorts(i, szPorts);
		
		// If there are any ports
		if (szPorts.GetLength() > 0 && szPorts[0] != 'N')	// 'N' means "N/A" or "N/S"
		{
			// Funny code to prefix each port with and IP address
			szPorts.Replace(",", '\n' + szIP + ':');
			// Now add an IP for the first one
			szPorts = szIP + ':' + szPorts + '\n'; 
		
			fputs(szPorts, fileHandle);
		}
	}	
}


BOOL CSaveToFile::queryFilename()
{
	CFileDialog fd(FALSE,"txt",NULL,OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		"Text files (*.txt)|*.txt|"
		"Comma-separated files (*.csv)|*.csv|"
		"HTML files (*.htm*)|*.htm*|"
		"XML files (*.xml)|*.xml|" 
		"IP-Port List files (*.lst)|*.lst||", 
		m_dlg);

	if (fd.DoModal() == IDOK)
	{		
		// Get filter index for determining the file format
		int nFilterIndex = fd.m_ofn.nFilterIndex;

		if (nFilterIndex == 2)
		{
			m_filetype = FILE_TYPE_CSV;
		}
		else
		if (nFilterIndex == 3)
		{
			m_filetype = FILE_TYPE_HTML;
		}
		else 
		if (nFilterIndex == 4)
		{
			m_filetype = FILE_TYPE_XML;			
		}
		else 
		if (nFilterIndex == 5)
		{
			m_filetype = FILE_TYPE_IPPORT_LIST;			
		}
		else
		{
			m_filetype = FILE_TYPE_TXT;
		}

		m_filename = fd.GetPathName();

		return TRUE;
	}
	else
	{
		return FALSE;
	}	

}




